[{"title":"RIDE安装初步测试","date":"2020-12-02T19:19:04.000Z","date_formatted":{"ll":"2020年12月2日","L":"2020/12/02","MM-DD":"12-02"},"updated":"2021-01-25T08:44:14.461Z","content":"\n\npython安装是否成功测试方法win+cmd，输入：python1234C:\\Users\\Administrator&gt;pythonPython 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt;\n\n安装失败的解决方法可能是没有添加环境变量。将\\Python27添加到环境变量当中\n右键我的电脑，点击属性 -&gt; 高级系统设置 -&gt; 系统变量 -&gt; Path -&gt; 编辑{% asset_img 1.png 这是RIDE安装初步测试的图片的说明 %}\n12345678910111213141516- 新建添加以下三个路径：  ![](image-20201207133601950-1608030530409.png)### pip安装是否成功#### 测试方法- 方法一：python安装路径**\\python27\\Scripts**中含有pip.exe  ![](image-20201207102421565-1608030321962.png)- 方法二：win+cmd，输入：`pip list`回车，是否含有pip- 方法三：\nC:\\Users\\Administrator&gt;pip --version\npip 20.3.1 from c:\\python27\\lib\\site-packages\\pip (python 2.7)\n\nC:\\Users\\Administrator&gt;\n12345678910#### 安装失败的解决方法- win+cmd，在下载的pip目录下输入：`python setup.py install`### 安装成功的库查询#### 查询方法win+cmd 输入：`pip list`，查看已经安装的插件包名字和版本，以下列出已安装库\nC:\\Users\\Administrator&gt;pip list\nrobotframework-archivelibrary   0.4.0\nrobotframework-ftplibrary       1.9\nrobotframework-ride             1.5\nrobotframework-selenium2library 1.7.4\nrobotframework-sshlibrary       3.5.1\n1234567891011121314151617#### 安装方式在cmd中输入相关指令:- pip install robotframework-selenium2library- pip install robotframework-archivelibrary- pip install robotframework-SSHLibrary- pip install robotframework-ftplibrary### wxPython#### 测试方法- win+cmd，输入：`python`- 继续输入：`import wx`- 结果不报错\nC:\\Users\\Administrator&gt;python\nPython 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import wx\n&gt;&gt;&gt;\n123456789101112131415161718192021222324252627282930#### 结果报错了解决方法- 输入：`ctrl+z`退出命令交互窗口- 继续输入：`pip  install  wxPython`- 安装后继续用测试方法测试是否安装成功## RIDE快捷键及图标设置#### 正确例子测试1. 打开python安装路径：**\\python27\\Scripts**，找到**ride.py**2. 右键**发送到（N）**，选择**桌面快捷键方式**3. 右键桌面ride快捷键，点击**属性**，选择**更改图标**4. 选择**\\Python27\\Lib\\site-packages\\robotide\\widgets\\robot.ico**5. 一路**确定**，修改完毕。## RIDE自建库测试方法1. 打开python安装路径：**\\Python27\\Lib\\site-packages**（所安装的插件的库都在这里），在这个文件夹中新建一个文件夹命名为：**NewLibrary**。文件夹名字就是自建库的名字。2. 在文件夹**NewLibrary**中新建一个**myclass.py**(以关键字命名)文件，用于存放自定义的方法。内容为:   ```python   class MyClass(object):       def __init__(self):           pass           def printMsg(self,msg):           print \"hello \"+msg在文件夹NewLibrary中新建一个_ __init___.py(以关键字命名)文件，用于存放自定义的方法。内容为:打开RIDE，点击File -&gt; New Project，创建项目Tesetnc：\n右键左上刚创建的项目Tesetnc，右击File -&gt; New Test Case，输入测试用例名称，点击OK：\n点击左上角项目Tesetnc，点击右侧Library，直接输入刚刚第一步新建的文件夹名称：NewLibrary。\n注意不要输错，输错会变红，变红色就是没有找到这个库。\n按F5，选择Source中第一步新建的库文件夹名字：NewLibrary，可以看到printMsg相关信息。\n点击测试用例test1，在第一列输入关键字（函数），后面每一列都是入口参数。在第一个入口参数输入：world\n点击左上测试用例test1，点击Run-&gt;Start，开始运行。快捷键：F8。可以看出输出结果为：hello world，验证成功。\n注：如果保证都没有错，但是一直都是红色，可能某个插件没有安装好，可以看ride的运行报错，按照报错进行修复。\n错误例子测试printMsg函数只有一个入口参数，手动输入两个参数：\n运行，报错：\n报错信息：FAIL : Keyword 'NewLibrary.Print Msg' expected 1 argument, got 2.NewLibrary这个库中的关键字PrintMsg只有一个入口参数，但是手动输入了两个参考文章【1】RobotFramework入门使用\n【2】Python3+Robot Framework+RIDE安装使用教程\n","plink":"http://yoursite.com/2020/12/02/RIDE安装print测试/"},{"title":"Part 2 | Lua语言基础","date":"2020-11-20T19:33:00.000Z","date_formatted":{"ll":"2020年11月20日","L":"2020/11/20","MM-DD":"11-20"},"author":"Sua-CQY","updated":"2021-01-25T08:32:14.324Z","content":"\n\n一、基本类型lua总共有8种基本类型：nil（空）、boolean（布尔）、number（数值）、string（字符串）、userdata（用户数据）、function（函数）、thread（线程） 和 table（表）。type返回的参数是string类型。最主要的一个例子为：\n1234&gt; type(nil)==nilfalse&gt; type(nil)==\"nil\"true\n\ntype（nil）返回的是字符串类型“nil”，所以输出为false。\n二、nilnil 类型表示一种无效值，主要作用为与其他值有所区分。\n12&gt; print(type(a))nil\n\n对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉：\n对于table\n1234567891011121314151617tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" }for k, v in pairs(tab1) do  print(k .. \" - \" .. v)endprint(\" ---------------- \" )tab1.key1 = nilfor k, v in pairs(tab1) do  print(k .. \" - \" .. v)end--[[输出：1 - val3key2 - val2key1 - val1 ---------------- 1 - val3key2 - val2--]]\n\n对于全局变量\n12x == nil     --&gt; truex == \"nil\"   --&gt; false\n\n三、Booleanboolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true。注意，在Lua中，任何值都可以表现条件，在条件检测中，空字符串和零也为真。\n123456789101112131415print(type(true))print(type(false))print(type(nil))if false or nil then  print(\"至少有一个是 true\")else  print(\"false 和 nil 都为 false\")endif 0 then  print(\"数字 0 是 true\")else  print(\"数字 0 为 false\")end\n\n以上代码执行结果如下：\n12345booleanbooleannilfalse 和 nil 都为 false数字 0 是 true\n\n不同于 C/C++，在 Lua 中对 0(number) 进行逻辑判断，得到的结果也是 true。\nBoolean在逻辑运算中的运用也十分重要。Lua的逻辑运算符为：and（与）、or（或），not（非）。\n逻辑运算符与and的运算结果\n​    若第一个操作数为false，则返回第一个操作数，否则返回第二个。\n逻辑运算符或or的运算结果\n​    若第一个操作数为false，则返回第二个操作数，否则返回第一个。\n速记口诀\n​    and假一，or假二。\n例程\n1234564 and 5        --&gt; 5  nil and 13     --&gt; nilfalse and 13   --&gt; false0 or 5         --&gt; 0false or \"hi\"  --&gt; hinil or false   --&gt; false\n\nand和or的短路求值原则\n​    短路求值原则即在有必要的时候求第二个操作数进行求值。\n123&gt; i=0&gt; i~=0 and a/i&gt;0false\n\n​    第一个操作数不满足且为与操作，因此直接就返回第一个操作数的结果false。\nx= x or v 的惯用写法等价于\n1if not x then x=v end\n\n三目运算a ? b : c\n12local a, b, ret;ret = a &gt; b and a or b\n\n上诉三目运算没有问题，但是按一般的形式：\n1a and b or c\n\n当a=true，b=false时，返回值就不在是b，而是c。这并不是我们所认识的正确值，所以这个一般形式的三目运算也是有他的坑，要注意使用时候要主要这个点。\n四、number（数值）五、string（字符串）字符串是由数字、字母、下划线组成的一串字符。有三种表示方式：\n1.双引号：”string1”\n2.单引号：‘string1’\n3.双个中括号：[[string1]]\n字符串相关函数：\nstring.upper(arg):字符串转化为大写字母\n123&gt; data='string'&gt; string.upper(data)STRING\n\nstring.lower(arg):字符串转化为小写字母\n123&gt; data='STRING'&gt; string.lower(data)string\n\nstring.reverse(arg):字符串反转，倒着输出\n12&gt; string.reverse('string')gnirts\n\nstring.len(arg):求字符串长度（空格也算）。空串 \"\" 的长度为 0\n123456&gt; string.len('string')6&gt; string.len('string ')7&gt; string.len('a\\000bc\\000')  -- 内嵌零也统计在内5\n\nstring.rep(string，n[, sep]):返回string的n个拼接，若sep不为空，则n 个字符串 string 以字符串 sep 为分割符连在一起的字符串。\n123456&gt; string.rep('string ',3)string string string&gt; string.rep('string',3)stringstringstring&gt; string.rep('string',3,\"a\")stringastringastring\n\nstring.sub(Str,from[，to]):截取下字符串Str从from到to,如果没有to参数，则默认to=-1。\n返回值：截取得到的字符串\n123&gt; data='i can can then can'&gt; string.sub(data,1,5)i can\n\nstring.gsub(mainString,findString,replaceString[,num]):将mainString中的findString替换成replaceString，替换num次。num若没有写，则全部替换。\n两个返回值：\n第一个返回值：替换后的字符串\n第二个返回值：替换次数\n12345&gt; data='i can can then can'&gt; string.gsub(data,'c','k',2)i kan kan then can      2&gt; string.gsub(data,'a','i')i cin cin then cin      3\n\nTODO：\nstring.find (str, substr, [init, [end]]):在字符串str中寻找是否存在substr子字符串，init是起始位置，第四个参数  true 时， 关闭模式匹配机制。 int和end都是可选参数。不存在返回nil，存在返回两个返回值。\n两个返回值：\n第一个返回值：存在子字符串的起始位置\n第二个返回值：存在子字符串的终止位置\n12345&gt; data='i can can then can'&gt; string.find(data,'can')3       5&gt; string.find(data,'can',5)7       9\n\nstring.format(...):格式化字符串，类似printf函数\n返回值：格式化后的字符串\n12&gt; string.format(\"the value is:%d\",4)the value is:4\n\nUDP/TCP传输数据的时候需要将数据转成字节数组，stringdump函数将string或者table格式的数据一行16个数据打印出来，如打印例子：\n12345678910----------------------------------------------------------------------------00000001 - ff aa 2a 10 00 10 8e 7b 22 63 6d 64 22 3a 22 30  ..*....{\"cmd\":\"000000011 - 30 31 32 31 30 30 30 32 30 30 30 30 30 30 30 5f  012100020000000_00000021 - 54 58 22 2c 22 67 22 3a 22 30 30 30 30 30 30 30  TX\",\"g\":\"000000000000031 - 34 39 41 38 33 31 33 30 2d 33 31 33 30 22 2c 22  49A83130-3130\",\"00000041 - 64 61 74 61 22 3a 7b 22 67 70 73 30 3a 31 2c 22  data\":{\"gp0\":1,\"00000051 - 66 72 65 65 73 70 61 63 65 22 3a 22 31 2e 33 4d  freespace\":\"1.3M00000081 - 37 33 22 2c 22 76 6f 6c 74 61 67 65 22 3a 22 33  73\",\"voltage\":\"300000091 - 2e 37 22 7d 7d d4 a3                             .7\"}}..----------------------------------------------------------------------------\n\n以上输出的代码为：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function stringdump( arg )    local dump    if type(arg) == 'string' then\t\tclog.info(\"dump type string.\")        dump = { arg:byte(1,-1) }    else\t\tclog.info(\"dump type arg.\")        dump = arg    end    local binstr = \"\"\tlocal addr = 0x00\tif arg == nil then\t\tclog.error(\"Try to dump nil data.\")\tend    print('-----------------------------------------------------------------------')\t    for i=1,#dump do        if 0 == ((i-1)%16) then            -- 打印序号            binstr = \"\" .. string.format( \"%08x -\",i + addr )            binstr = binstr .. string.format( \" %02x\", dump[i] )        elseif (15 == ((i-1) % 16)) then            binstr = binstr .. string.format( \" %02x\", dump[i] )            binstr = binstr .. \"  \"            for j=i-15, i do                -- 打印不出来、显示不出来的字符用.代替                if (0x20 &lt;= dump[j]) and (dump[j] &lt;= 0x7e) then                    binstr = binstr .. string.format( \"%c\", dump[j] )                else                    binstr = binstr .. '.'                end            end            print(binstr);        else            binstr = binstr .. string.format( \" %02x\", dump[i] )        end    end\t-- 排除最后一行不超过16个的情况    if 0 ~= ((#dump)%16) then        local k = 16 - ((#dump) % 16);        for j=1,k do            binstr = binstr .. \"   \"        end        binstr = binstr .. \"  \"        k = 16 - k;        for j=#dump-k+1, #dump do            if (0x20 &lt;= dump[j]) and (dump[j] &lt;= 0x7e) then                binstr = binstr .. string.format( \"%c\", dump[j] )            else                binstr = binstr .. '.'            end        end\t\tprint(binstr);    end    print('------------------------------------------------------------------------')end\n\nstring.char(arg) :将整型数字转成字符并连接\n12345&gt; string.char(97,98,99,100)abcd&gt; string.char(97,98,99,10)abc-- 10输出不出来，这就是为啥上诉要排除小于等于0x20，大于0x7e的数\n\nstring.byte(arg[,int]):转换字符为整数值\n12345&gt; string.byte(\"ABCD\",4)68&gt; string.byte(\"ABCD\")65&gt;\n\nstring.gmatch (s, pattern)\n回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。\n1234&gt; for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) endHelloLuauser\n\nstring.match (s, pattern [, init])\n只寻找str中的第一个配对，参数init指定搜寻起点, 默认为1。\n返回值：\n在成功配对时, 函数将返回配对表达式中的所有捕获结果;如果没有设置捕获标记, 则返回整个配对字符串.当没有成功的配对时, 返回nil12345&gt; = string.match(\"I have 2 questions for you.\", \"%d+ %a+\")2 questions&gt; = string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\"))2, \"questions\"\n\nstring.pack (fmt, v1, v2, ···)\nstring.packsize (fmt)\nstring.unpack (fmt, s [, pos])\nstring.dump (function [, strip])\n六、table（表）table相关函数：\ntable.concat (table [, sep [, start [, end]]])\n列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。如果 start  比 end大，返回空串。\n123456789101112131415fruits = {\"banana\",\"orange\",\"apple\"}-- 返回 table 连接后的字符串print(\"连接后的字符串 \",table.concat(fruits))-- 指定连接字符print(\"连接后的字符串 \",table.concat(fruits,\", \"))-- 指定索引来连接 tableprint(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))[[连接后的字符串     bananaorangeapple连接后的字符串     banana, orange, apple连接后的字符串     orange, apple--]]\n\ntable.insert (table, [pos,] value)\n在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾:#table+1。\n1234567891011121314ruits = {\"banana\",\"orange\",\"apple\"}-- 在末尾插入table.insert(fruits,\"mango\")print(\"索引为 4 的元素为 \",fruits[4])-- 在索引为 2 的键处插入table.insert(fruits,2,\"grapes\")print(\"索引为 2 的元素为 \",fruits[2])[[索引为 4 的元素为     mango索引为 2 的元素为     grapes--]]\n\ntable.maxn (table)\n指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法不存在)\n1234567tbl = {[1] = 2, [2] = 6, [3] = 34, [26] =5}print(\"tbl 最大值：\", table_maxn(tbl))print(\"tbl 长度 \", #tbl)[[tbl 最大值：    34tbl 长度     3--]]\n\ntable.remove (table [, pos])\n返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。\n12345678ruits = {\"banana\",\"orange\",\"apple\"}print(\"最后一个元素为 \",fruits[5])table.remove(fruits)print(\"移除后最后一个元素为 \",fruits[5])[[最后一个元素为     mango移除后最后一个元素为     nil--]]\n\ntable.sort (table [, comp])\n对给定的table进行升序排序。\nTODO1;comp\n1234567891011121314151617181920212223fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"}print(\"排序前\")for k,v in ipairs(fruits) do        print(k,v)endtable.sort(fruits)print(\"排序后\")for k,v in ipairs(fruits) do        print(k,v)end[[排序前1    banana2    orange3    apple4    grapes排序后1    apple2    banana3    grapes4    orange--]]\n\ntable.move (a1, f, e, t [,a2])将元素从表 a1 移到表 a2。 这个函数做了次等价于后面这个多重赋值的等价操作： a2[t],··· = a1[f],···,a1[e]。 a2 的默认值为 a1。 目标区间可以和源区间重叠。 索引 f 必须是正数。\ntable.pack (···)返回用所有参数以键 1,2, 等填充的新表， 并将 “n“ 这个域设为参数的总数。 注意这张返回的表不一定是一个序列。\ntable.unpack (list [, i [, j]])返回列表中的元素。 这个函数等价于\n1return list[i], list[i+1], ···, list[j]\n\ni 默认为 1 ，j 默认为 #list。\n七、function（函数）略\n八、thread（线程）略\n九、userdata（用户数据）略\n","plink":"http://yoursite.com/2020/11/20/Lua语言基础2/"},{"title":"Part 1 | Lua语言基础","date":"2020-10-29T16:51:00.000Z","date_formatted":{"ll":"2020年10月29日","L":"2020/10/29","MM-DD":"10-29"},"author":"Sua-CQY","updated":"2021-01-25T08:32:39.359Z","content":"\n\n一、简述从2018年10月开始学习Lua语言，主要运用于合宙二次开发的产品开发。前期都是开发没有及时的总结、系统的学习Lua语言的知识体系，对Lua只是处于知其然，不知其所以然的状态。现在有比较多的碎片化时间去学习总结，因此从梅隆魁所译的《Lua程序设计》第四版开始入手学习总结出我所认为的重点与知识点，希望对后期的运用有所帮助。\n最笼统的认识要从每本书的序言开始，序言对Lua的描述是：被游戏行业所广泛运用的“胶水语言”，最著名的莫过于魔兽世界。Lua是嵌入式的脚本语言，特点是轻量、高效、简单，可扩展等，它可独立进行编程，也可作为一个库嵌入到其他宿主语言的应用程序中。Lua语言还有一个特点是一种动态类型的语言，它没有类型定义，每个值都带有自身的类型信息。\n二、在Win的编译环境安装（一）、 SciTE的IDE1.在官网下载Full 64-bit download\n2.解压压缩包，安装SciTE\n（二）、官网Win的编译环境点击Lua官网的下载区，在History找到最新的下载包点击[Tools Executables](https://sourceforge.net/projects/luabinaries/files/5.4.0/Tools Executables/)选择lua-x.x.x_Win64_bin.zip，目前最新的下载包为[lua-5.4.0_Win64_bin.zip](https://sourceforge.net/projects/luabinaries/files/5.4.0/Tools Executables/lua-5.4.0_Win64_bin.zip/download)在目录中解压压缩包到自定义目录，为1.解压区样式，若只安装了这一版lua编辑器，即可将命名改成2.修改区样式。（dll文件不要修改，否则cmd会报错）\n5.将目录加入环境变量中，按Win-&gt;输入环境变量-&gt;点击编辑系统环境变量-&gt;点击环境变量-&gt;选择系统变量中的Path-&gt;点击编辑-&gt;添加解压包根目录-&gt;确定-&gt;确定\n6.添加完毕，Win+R，输入cmd调出命令行，若第四步没有修改，输入luaxx（如第四步图lua54）回车，如果修改成lua则输入lua回车，显示出版本号为成功。\n\n（三）、Visual Studio Code安装不赘述，官网下载安装包安装必用：扩展插件、源代码管理器，可以上传代码到GitHub，并进行代码比对。好用的扩展插件：Chinese (Simplified) Language Pack for Visual Studio CodemsCode alignmentLuaCoderAssistLUATvscode-luaemLuaIDE（四）、LuaEditor安装不赘述，百度下载安装包安装三、第一个Lua程序1.程序Hello World!\n1print(\"Hello World!\")\n\n2.cmd命令行的交互式编程模式\n12345C:\\Users\\cqy1620&gt;lua -iLua 5.4.0  Copyright (C) 1994-2020 Lua.org, PUC-Rio&gt; print(\"Hello World!\")Hello World!&gt;\n\n3.交互模式下dofile文件HelloWorld.lua\n12345C:\\Users\\cqy1620&gt;luaLua 5.4.0  Copyright (C) 1994-2020 Lua.org, PUC-Rio&gt; dofile(\"c:\\\\Users\\\\cqy1620\\\\Desktop\\\\HelloWorld.lua\")Hello World!&gt;\n\n4.命令行输入命令脚本编程，执行HelloWorld.lua\n1234C:\\Users\\cqy1620&gt;cd \\Users\\cqy1620\\DesktopC:\\Users\\cqy1620\\Desktop&gt;lua HelloWorld.luaHello World!\n\n注：Ctrl+Z退出交互模式，回到命令行状态\n5.杰斌教学:输出重定向\nC:\\Users\\cqy1620\\Desktop\\HelloWorld.lua运行前1print(\"Hello World!\")\n\ncmd命令行输入1C:\\Users\\cqy1620&gt;echo \"Hello world\" &gt;&gt; C:\\Users\\cqy1620\\Desktop\\HelloWorld.lua\n\n结果：C:\\Users\\cqy1620\\Desktop\\HelloWorld.lua运行后12print(\"Hello World!\")\"Hello world\"\n\n四、语法基础注释单行注释：–多行注释：1234567891011--[[第一种多行注释]]--[[第二种多行注释--]]---[[  -- 类似单行注释重新启动多行注释--]]   -- 类似单行注释\n\n2.标识符\nLua 标示符不能以数字开头，是由字母、数字、下划线组成的字符串。Lua对大小写敏感，因此DATA和Date是不同的标识符。\n注意“下划线+大写字母”的标识符通常被Lua语言作为特殊用途，“下划线+小写字母”的标识符作为哑变量。例如：\n _VERSION: 一个包含有当前解释器版本号的全局变量。 当前这个变量的值为 “Lua 5.4“\n1234C:\\Users\\cqy1620&gt;luaLua 5.4.0  Copyright (C) 1994-2020 Lua.org, PUC-Rio&gt; _VERSIONLua 5.4\n\n**哑变量：**又称为虚拟变量、名义变量，就是没有现实意义，没啥用。\n12345678910111213141516171819local filename = \"baiyin201904huadan.zip\" beginPos, endPos = string.find(filename, \".zip\") if endPos == string.len(filename) then     print(\"beginPos : \" .. beginPos .. \" | endPos : \" .. endPos .. \" | len : \" .. string.len(filename)) end  print(\"-----------------------------------\")  _, endPos = string.find(filename, \".zip\") if endPos == string.len(filename) then     print(\"endPos : \" .. endPos .. \" | len : \" .. string.len(filename)) end  -- 输出 --[[ beginPos : 19 | endPos : 22 | len : 22 ----------------------------------- endPos : 22 | len : 22 --]]\n\n3.全局变量与局部变量\n**全局变量：**全局变量不需要声明即可使用，访问一个没有初始化的全局变量也不会出错，其结果是：nil。如果要回收一个变量就赋值nil给他。\n123456789&gt; a      -- 没有声明变量nil&gt; a=1    -- 赋值&gt; a1&gt; a=nil   -- 回收变量&gt; anil&gt;\n\n**局部变量：**局部变量生效的范围仅在他声明的代码块中，一个代码块是一个控制结构的主体、一个函数主体或者是一个代码段。\n123456789101112131415local i,x=1,10                  -- 这一代码块有效 print(\"First print:\"..x)if i&lt;x then\tlocal x=100                 -- if判断语句中有效\tprint(\"Second print:\"..x)   else\tprint(\"Third print:\"..x)    -- 全局变量endprint(\"Fourth print:\"..x)       -- 全局变量 -- 输出 --[[ First print:10 Second print:100 Fourth print:10 --]]\n\n4.类型\n动态类型语言特点是不用定义类型，直接赋值即可使用。lua总共有8种基本类型：nil（空）、boolean（布尔）、number（数值）、string（字符串）、userdata（用户数据）、function（函数）、thread（线程） 和 table（表）。\n12345678type(nil)              --&gt; nil    type(true)             --&gt; booleantype(10.4*3)           --&gt; numbertype(\"Hello world\")    --&gt; stringtype(io.stdin)         --&gt; userdatatype(print)            --&gt; functiontype(type)             --&gt; function           type(type(X))          --&gt; string\n\n注意：type返回的参数是string类型\n","plink":"http://yoursite.com/2020/10/29/Lua语言基础/"},{"title":"SK-121-4G-AT任务分配","date":"2020-10-21T09:52:00.000Z","date_formatted":{"ll":"2020年10月21日","L":"2020/10/21","MM-DD":"10-21"},"author":"Sua-CQY","updated":"2020-10-21T04:21:32.591Z","content":"\n\n一、说明按代码的具体运行流程看代码，不懂的及时到WIKI或者是官网下载的LuaTask中的doc中查看相关的html文件的具体解析。从某个线程入手，要求掌握几点：\n代码运行的顺序，代码大体框架（参考学习笔记2.0中的框架）；每个线程的作用、各个线程之间的联系；掌握基本学习方法，了解lua基本知识和用法；掌握通用、可移植的基本代码；按要求增添功能，调bug；做好学习笔记、代码备注、版本说明。以下以线程的增减功能或测试功能来进一步学习，每个任务优先级从低到高，可以自行完成。有问题及时记录并提问。\n二、线程一：ducr_test与test_mode双核心测试线程，主要是开机初始化、模式检测及状态更新检测。需要完成的任务如下：\n使用SecureCRT与LuaTools每5分钟打印一次以下几个参数：g_tts_default、nameValue、test_mode_state、record_state。开机后播报完“欢迎使用本产品”后，再播放一句当前时间，格式为：年月日时分秒。定时电压、信号检测并播报，播报后快闪三下。将测试模式修改成：短按小键开始录音，短按大键播放当前电压、信号强度、版本信息、当前时间（格式为年月日），长按大键拨号10086，长按小键挂断，超过2分钟无操作退出测试模式。添加一个线程，只要当进入测试模式时，无操作每隔30秒语音提醒“当前处于测试模式，请注意”，播放完毕慢闪2下，并发送一个数据包给服务器，数据包格式：1234567891011{​\t\"cmd\": \"SK121P_4G_AT_test\", ​\t\"g\": \"xx“, ​\t\"data\": {\t\t\t\"time\": 1111111111,\t\t    \"voltg\": 4000,\t\t\t\"test_mode\":1​\t        }}\n三、线程二：p_call_check_state通话状态检测线程，主要作用为检测当前的通话状态。需要完成的任务如下：\n使用SecureCRT与LuaTools每5分钟打印一次以下几个参数：g_call_time、hang_on、led_off、calling_table。短按报时修改成：当前时间为xx，xx格式为：年月日时分秒。定时电压、信号检测并播报，播报后快闪三下。定时拨号给某个人，拨号如果成功结束播放“情况异常，汇报成功”，并慢闪两下，如果拨号失败，轮播白名单第7到第9个电话号码，直到接通为止，如果都没有接通，则汇报“情况异常，汇报失败，将三分钟后进行重拨”，定三分钟后重拨。添加一个线程，通话记录四种状态：接通、未接、呼叫成功，呼叫失败，每个状态给单片机发送一个数据包，数据包要用到table相关用法，具体数据包定义如下：\n通话状态数据包类型\n\n接通1A\n\n未接1B 2B\n\n呼叫成功3C\n\n呼叫失败4D\n\n包头数据包类型数据包长度校验\n\nFF AA1A(接通)01所有字节算术加取反\n四、时间安排任务难度逐级递增，但是有相关代码作为参考，难度不算太大。按照当前课表以及学习进度，做以下规划：\n\n日期10.2110.2210.2310.2410.25\n\n任务一完成\n\n任务二完成完成\n\n任务三完成完成\n\n任务四完成\n\n任务五完成\n五、其他记录问题及解决方法，重点知识要做笔记。测试、编写有相关问题，先自行解决，没找到解决办法，可以发一下给我。每天在群里汇报当天进度，任务是否完成，周三、周日汇报进度给杜老师，邮件抄送成员。","plink":"http://yoursite.com/2020/10/21/SK-121P-4G-AT任务分配/"},{"title":"有线电话通信原理及DTMF学习","date":"2020-08-15T14:03:00.000Z","date_formatted":{"ll":"2020年8月15日","L":"2020/08/15","MM-DD":"08-15"},"author":"巧玉","updated":"2020-11-20T11:44:00.196Z","content":"\n\n\n一、简述在现代生活中固话逐渐被智能机给替代，但是有线报警主机在未升级版本依然走的是CID格式，全部替换老式有线报警主机成本高，大多人会选择在有线报警主机基础上，安装小模块来升级报警通道2G、4G、有线等，但是有线电话报警依然需要保留，并且由有线引申到其他升级通道报警。\n二、有线电话通信2.1 专有名词解释CID：安定宝 (ADEMCO) Contact ID 报警通讯格式，在有线电话网中与报警信号接收器、接警中心之间的一种协议，在国内十分普及。\nDTMF： 报警信息数据，百度解释：双音多频，由高频群和低频群组成，高低频群各包含4个频率。一个高频信号和一个低频信号叠加组成一个组合信号，代表一个数字。拨号的时候，将号码发出的也是DTMF格式。\nPSTN： 公共电话交换网。\nPBX： 电话交换机。\n摘机（提机）： 固定电话拿起电话机的听筒或按免提。\n拨号音： 当用户摘机后，系统向电话发出450Hz连续音频信号。\n忙音：当用户拨打一个正在通话中的号码时，系统向电话机发出450Hz的音频信号，响0.35s停0.35s。\n催挂音： 通话结束，一方挂机或呼叫失败时，系统向电话发出450Hz的音频信号，响0.7s，停0.7s。\n回铃音： 拨号一个有效号码，且正在呼叫，被呼叫用户摘机前听到的系统向电话机发出的450Hz音频信号，响1s，停4s，直到接通或挂机。\n三、模块解读3.1 HT9170芯片解读主要作用：DTMF解码\n\n\nVP运算放大器同相输入VDD电源，工作电压2.5V~5.5V\n\nVN运算放大器反相输入RT/GT音频采集时间和发布时间\n\nGS运算放大器输出端子EST早起转向输出\n\nVREF参考电压VDD/2DV接收到DTMF码时为高电平\n\nINH逻辑高D3接收数据输出\n\nPWDN高，掉电模式D2接收数据输出\n\nX1晶振3.579545MHzD1接收数据输出\n\nX2晶振3.579545MHzD0接收数据输出\n\nVSS负电源，地面OED3~D0输出使能，高电平有效\n\n检测原理\n有DTMF数据时DV脚为高电平检测到DV脚为高电平时要将OE脚拉高，使能D0-D3的输出接收DTMF的D3-D0数据并解析，解析表格如下：\n3.2 MX801解读主要功能：内部铃流、摘挂机检测\n芯片手册中的功能原理框图以及引脚说明图：\n\n\n\n学习要点\nAIN接724模块的SPK+，AOUT接724模块的麦克风MIC+，能够让4G模块转拨号单片机检测SHK脚，摘机高电平\n","plink":"http://yoursite.com/2020/08/15/有线电话通信原理及DTMF学习/"},{"title":"Lua学习总结","date":"2020-07-28T14:03:00.000Z","date_formatted":{"ll":"2020年7月28日","L":"2020/07/28","MM-DD":"07-28"},"author":"巧玉","updated":"2021-01-25T06:39:38.859Z","content":"\n\n一、简述1.1 缘由&nbsp;&nbsp;公司主要是以AT开发，所以杜老师想让我和大家说一下lua开发。lua开发大哥带的我，这边都没有人会，所以这个难得的机会被我遇到了。之前大概4月末左右杜老师就让我开始准备，准备到现在7月末了，我不是一般的拖拉。上周借开会的名义和同学们分享了两个多小时，我发现我也学到好多，进一步了解了lua，真的自己学不如给别人讲讲，越讲疑点越多，越多就会越思考。\n1.2 邮件内容研发部前辈们：             &nbsp;&nbsp;&nbsp;&nbsp;您们好！            &nbsp;&nbsp;&nbsp;&nbsp;我是研发部的实习生陈巧玉，很荣幸获得这次机会能与大家分享我所学习、所认识的Lua语言，7月28日即今天晚上6:30在会议室中，若您感兴趣，可以来听一听，期待您的到来。\n   &nbsp;&nbsp;&nbsp;&nbsp;据了解，我司在合宙产品中最主要是用AT开发，相对于AT开发，Lua开发有以下几点优势：\nLua语言简单易学，容易上手，代码量小API丰富供使用者调用，除了标准API，合宙方还支持许多拓展API例程丰富，合宙提供大部分功能的例程，lib库也是完全开源的接口说明详细合宙提供wiki网站、本地网页详细的对API参数、返回值等进行解释，并带有使用例子相关学习链接合宙模块Lua资料汇总：https://ask.openluat.com/article/1039Lua菜鸟教程：https://www.runoob.com/lua/lua-tutorial.htmlLua 5.3参考手册：https://www.runoob.com/manual/lua53doc/manual.htmlbit位操作库说明：http://note.youdao.com/noteshare?id=59be98b8eadc12c417edb9310cb6e11f附件是今晚我要讲的PPT、我所整理的资料合集与需要分析的lua文件，希望对您有所帮助，谢谢！如果您想进一步了解Lua语言，今晚6:30在会议室，期待您的出现。-——————————————————————————————-\n   &nbsp;&nbsp;&nbsp;&nbsp;此致敬礼   \n二、快速入门2.1 注释方法12345678910111213141516-- 单行--[[多行注释方法1local a]]--[[多行注释方法2local a--]]-- 灵活注释、解除注释，多加-即可取消注释，删除一个-即可注释这部分内容---[[local a--]]\n2.2 基本类型&nbsp;&nbsp;&nbsp;&nbsp;八种基本类型： nil、boolean、number、string、function、userdata、 thread 和 table\n123456-- 布尔类型为 true和false 那0是真还是假？if 0 then\tprint(\"0 is true\")else\tprint(\"0 is false\")end\n12-- 输出print(\"0 is true\")\n&nbsp;&nbsp;&nbsp;&nbsp;false和nil是false，其他true。\n2.3 变量1234567-- 局部变量-- 在被声明的代码块内有效，函数体内、所在文件内local a               -- 值为nillocal a,b,c = 1,2,3   -- 多重定义 a=1, b=2, c=3local tjsondata,result,errinfo = json.decode(string)  -- 多个返回值，逐一赋值-- 全局变量a = 1\n2.3 数组与表数组：索引值为数字，递增且连续table：索引可以为所以类型，除了nil定义：local table_A = {}1234567891011121314151617181920212223242526272829-- 定义空表local table_A = {}  local table_B = {}-- table_B中a索引为\"cmd\",table_A索引值为1-- 表中能够嵌入表local table_B = {cmd=\"a\",lb=\"b\",acc=\"c\",table_A}-- 取表中的值有以下两种方法table_B.cmd = \"a\"table_B[\"cmd\"] = \"a\"-- 求数组长度：#print(#table_A)-- 引用来自：https://linux.cn/article-9810-1.htmlt={}t[{}] = \"table\"                 -- key 可以是表t[1] = \"int\"                    -- key 可以是整数t[1.1] = \"double\"               -- key 可以是小数t[function () end] = \"function\" -- key 可以是函数t[true] = \"Boolean\"             -- key 可以是布尔值t[\"abc\"] = \"String\"             -- key 可以是字符串t[io.stdout] = \"userdata\"       -- key 可以是userdatat[coroutine.create(function () end)] = \"Thread\" -- key可以是threadfor k,v in pairs(t) do  print(k,\"-&gt;\",v)end\n2.4 字符拼接1234567local a = \"abc\"local b = \"def\"print(a..b)--[[ 输出：\t     abcdef]]\n2.5 函数定义123function function_name()\t-- bodyend\n2.6 if语句123456789101112-- 格式1if condition then\t-- bodyelse\t-- bodyend-- 格式2if condition then\t-- bodyelseif condition then\t-- bodyend\n2.7 while语句123while condition do\t-- statementsend\n2.8 for语句123456789101112-- 格式1for i=1,10 do\tprint(i)end-- 格式2for i,v in ipairs(table_name) do\tprint(i,v)end-- 格式3for i,v in pairs(table_name) do\tprint(i,v)end\n2.9 逻辑运算不等于 ：~=与或非：and or not2.10 拓展库&nbsp;&nbsp;&nbsp;&nbsp;bit位操作、json编码与解码等\n1234bit.bnot 取反bit.band 与操作bit.bor 或操作bit.bxor 异或操作\n三、table嵌套2.1 获取表中参数两种方式1234567891011121314151617Heart_Beat1 = {    cmd  = \"CMD_HB_TX\",    g    = \"131\",    data =     {        tim  = 12,        valt = 4.0,        csq  = 3    }}print(Heart_Beat1.g)print(Heart_Beat1.data.tim)print(Heart_Beat1.data.csq)print(Heart_Beat1[\"g\"])print(Heart_Beat1[\"data\"][\"tim\"])print(Heart_Beat1[\"data\"][\"csq\"])\n1234567-- 输出131123131123\n2.2 table嵌套1234567891011121314151617181920212223local table_A = {    x = \"test2\",      y = \"test3\",      z = \"test5\" ,}local table_B = {    x = 1,    y = 2,    z = 3,    {\ta = -1, a1 = 1}, -- 索引为1    {\tb = -2, b1 = 2}, -- 索引为2    {\tc = -3, c1 = 3}, -- 索引为3    table_Data = table_A,}table_B.table_Data = table_Aprint(table_B.y)print(table_B[1].a)print(table_B.table_Data.x)\n1234-- 输出2-1test2\n2.3 table嵌套思考题12345678910local Heart_Beat2     = {}Heart_Beat2.cmd       = \"CMD_HB_TX\"Heart_Beat2.g         = \"131\"Heart_Beat2.data.tim  = 12Heart_Beat2.data.volt = 4.0Heart_Beat2.data.csq  = 3print(Heart_Beat2.g)print(Heart_Beat2.data.tim)print(Heart_Beat2.data.csq)\n1234-- 输出c:\\users\\cqy1620\\desktop\\main.lua:189: attempt to index field 'data' (a nil value)Stack Traceback:        c:\\users\\cqy1620\\desktop\\main.lua:189: in main chunk\n&nbsp;&nbsp;&nbsp;&nbsp;为什么是错的呢?先思考到底是哪一步出错，哪一步可能出错。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一眼的第一个疑点就是Heart_Beat2.data是哪里来的？按写法，Heart_Beat2.data的类型是个table，所以定义一下即可。添加定义：\n1Heart_Beat2.data      = {}\n三、table遍历3.1 数组和table区别初始化数组时不需要填写索引，自动从数字1开始升序标好table可以实现数组，所以可以想成数组时table的子集在Lua中，table既不是“值”，也不是“变量”，而是对象。可以将table想象成一种动态分配的对象，程序中仅仅有一个队它们的引用（指针）。3.2 pairs和ipairs区别pairs\n&nbsp;&nbsp;&nbsp;&nbsp;pairs 能遍历集合的所有元素。即 pairs 可以遍历集合中所有的 key，并且除了迭代器本身以及遍历表本身还可以返回 nil。每次遍历的输出是随机的。\nipairs\n&nbsp;&nbsp;&nbsp;&nbsp;ipairs 仅遍历值，按照索引升序遍历，索引中断停止遍历。即不能返回 nil,只返回 0，若遇到 nil 则退出。只能遍历到第一个不是整数的 key。\n总结\n&nbsp;&nbsp;&nbsp;ipairs遍历数组、pairs遍历数组和table均可遍历所有key，但是ipairs遍历数组，只能从1开始升序、按顺序遍历出相对应key，若索引中断，则退出。\n&nbsp;&nbsp;&nbsp;&nbsp;有i就任性，i有i的想法，按顺序遍历\n3.3 pairs和ipairs例子栗子1123456789local table_A = {\t[1] = \"tab2\",\t[2] = \"tac3\",\t[5] = \"tad1\"}for k, v in ipairs(table_A) do  \tprint(k, v)end\n123-- 输出1tab22tac3\n原因\n&nbsp;&nbsp;&nbsp;&nbsp;ipairs只能按升序123456…..遍历，数字不连续或者为空则退出。\n栗子2123456789local table_A = {\t[\"1\"] = \"tab2\",\t[6]   = \"tac3\",\t[4]   = \"tad1\"}for k, v in ipairs(table_A) do  \tprint(k, v)end\n原因\n&nbsp;&nbsp;&nbsp;&nbsp;[“1”]类型是字符串，非数字。\n栗子3123456local table_A = {\"a\", \"ta\",[3] = \"no\",[\"two\"] = \"yes\"}  for i,v in ipairs(table_A ) do  \tprint( i..table_A [i] )   end  \n1234-- 输出1a2ta3no\n原因\n&nbsp;&nbsp;&nbsp;&nbsp;无定义索引，则自动赋值作为索引，依次递增。\n栗子4123456local table_A = {\"a\", \"ta\",[3] = \"no\",\"add\",\"fhi\",[\"two\"] = \"yes\"}  for i,v in ipairs(table_A ) do  \tprint( i..table_A [i] )   end   \n12345-- 输出1a2ta3add4fhi\n原因\n&nbsp;&nbsp;&nbsp;&nbsp;自动赋值作为索引的优先级比手动赋值的优先级高（我们自己的猜测）\n栗子5123456local table_A = {\"a\", \"ta\",[3] = \"no\",\"add\",\"fhi\",[\"two\"] = \"yes\"}  for i,v in pairs(table_A ) do  \tprint( i..table_A [i] )   end   \n123456-- 输出1a2ta3add4fhitwoyes\n原因\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个不知道如何解释，没有找到相关的解说。\n四、开发雷点创建UDP后，UDP收发函数只能在所创建的文件中调用，不能再其他文件调用，否则会异常重启上述收发函数也不能再定时器、回调函数中调用回调函数最好越简单越好，否则会出现一些奇奇怪怪的报错每个.lua文件最好最好留空几行，否则有些会报错报错信息是以堆栈式打印出来，所以要从下往上看多打log，可以用clog来打印日志，再用SecureCRT来看，事半功倍，但是这样是抓不到底层的日志LuaTools安装目录中的log文件夹中日志要及时清理，否则一天好几个G会占很多内存空间clog不能打印table、boolean类型测试socket连接，IP需要用公网IP，不能用局域网ipairs和pairs区别很重要拨号和TTS会冲突，TTS和TTS也会有冲突，可以调用TTS的回调函数，当TTS播放成功再进行播放下一TTS底层core几个版本的区别require了模块，参数也定义了，但是依然报错，可以在main.lua或则在main.lua所调用的模块文件内对每个人文件的变量进行调用打印一次，再删除报错就会消失。报错详情：五、总结&nbsp;&nbsp;&nbsp;&nbsp;难得这次一点都不磕磕巴巴，不知道是不是上周在摄影小哥的历练之下，我的脸皮堪比城墙，一点都不紧张。这次也算是一次成长。鸡汤总结：\n大场子提前上个厕所，多多深呼吸，暗示自己尽全力就好在没有很正式的场合时候，嬉皮笑脸点分享会得到更多的反馈只有不断暴露出来的缺陷才能修炼成完美不要过分在意别人的看法，活出自我就好，别人没空搭理你","plink":"http://yoursite.com/2020/07/28/Lua学习总结/"},{"title":"LabVIEW Notes","date":"2020-06-20T09:19:04.000Z","date_formatted":{"ll":"2020年6月20日","L":"2020/06/20","MM-DD":"06-20"},"updated":"2020-07-30T03:16:13.130Z","content":"\n\n一、概念&nbsp;&nbsp;&nbsp;&nbsp;电子信息工程专业的学费没有白交，从CAD、matlab到quartus、modelsim、multisim，现在有学会一项labview，感觉5000块很值。大三下这个课设感觉是最有意思的，没有硬件，但是也要画电路图。这个课设的难度我感觉是在安装软件上，劳动节放假别人放假我安软件，电脑都濒临崩溃。软件难装、又大，网络一直失败，安装好只要将控件搭好，训练一下abc，就能够完成。做完感觉学到好多东西。以下好多来自官网的翻译。\n1.1 视觉采集软件（VAS）描述：视觉采集软件（VAS）是一组驱动程序和实用程序，用于采集，显示和保存各种摄像机类型的图像，包括使用GigE Vision，IEEE 1394（FireWire），USB 2.0，USB 3的摄像机Vision或Camera Link标准。所属模块： VAS包含在VDM和VBAI中用法： NI Vision Acquisition Software（VAS）附带的驱动程序允许您从各种摄像机获取，显示和保存图像。但是，只有NI VDM和NI VBAI软件包能够支持对高级图像处理和分析。组件： VAS由以下三个驱动程序组成。有关这些驱动程序的更多信息，请参阅NI-IMAQ，NI-IMAQdx和NI-IMAQ I / O之间的差异​ NI-IMAQ - 从National Instruments帧抓取器获取数据，以及具有常规显示，保存文件和采集数据等功能NI-IMAQdx - 从GigE Vision、IEEE-1394相机、符合DirectShow标准的USB相机（VAS 2009及以上版本）以及一些IP相机中获取。NI-IMAQ I / O - PCI-8254R，PCI-8255R等紧凑型视觉系统中包含的FPGA配置1.2 视觉开发模块（VDM）描述：视觉开发模块（VDM）能为LabVIEW，C / C ++，Visual Basic和.NET环境提供机器视觉和图像处理功能所属模块： VDM是安装在LabVIEW中的单独许可模块组件： VDM 包括 视觉助手(Vision Assistant)工具，一个代码成型和生成工具，类似于NI 视觉生成器的菜单驱动界面。 视觉助手是一个用于开发和测试一系列图像分析和处理步骤，同时可以从中生成代码的工具。用法：通常，VDM功能用于图像处理和分析。其用途包括：模式匹配，粒子分析，边缘检测，阈值处理，直方图和光学字符识别。Windows和LabVIEW Real-Time支持视觉开发模块。这意味着您可以在远程目标上使用VDM，例如NI CVS（紧凑视觉系统）或NI智能相机。1.3 用于自动检测的视觉生成器（VBAI）描述：用于自动检测的视觉生成器（VBAI）是一个独立的，可配置的机器视觉开发环境，无需编程知识就可使用。组件： VBAI包括100多种常用的视觉开发工具，包括模式匹配，光学字符识别和粒子分析。它还内置了VAS，用于从相机获取图像。用法： VBAI可以对远程目标（包括实时控制器和FPGA）执行图像处理检测，还可以用于配置这些环境。1.4 下载地址\nhttp://search.ni.com/nisearch/app/main/p/bot/no/ap/tech/lang/zhs/pg/1/sn/ssnav:dwl/q/VAS/\n\n二、遇到的问题2.1 问题： 安装IMAQ和IMAQdx成功，但是在labview中没有显示IMAQdx？\n解决方法：\n&nbsp;&nbsp;&nbsp;&nbsp;打开电脑【面板控制】-【程序与功能】-【National instruments software】查看是否有要更新的，有的话更新重启，还不行就选择NI-IMAQdx-【修复】\n\n&nbsp;&nbsp;&nbsp;&nbsp;依然没有NI-IMAQdx，就是因为NI-IMAQdx没有破解。\n官网解释：\n\n2.2 如何破解？工具：NI LicensesActivatorCSDN免费下载：https://download.csdn.net/download/hefangli07/10802591教程说明：http://visionbbs.com/thread-490-1-1.html?tdsourcetag=s_pctim_aiomsg2.3 问题：安装后运行Grab.vi和IMAQdx例程都失败？保存详情：IMAQ(待解决):\nIMAQdx：\n解决方法：\n我先找到NI MAX查看笔记本摄像头是否存在：\n结果是存在的，将例程中的Interface Name改成cam0，IMAQ INIT.VI中的Interface Name也改成cam0，运行依然失败。后面感觉是版本问题。labview2018，IMAQ和IMAQdx都是2019的，重装成2019的IMAQdx就成功了，但是IMAQ例子运行依然失败注意：安装Vas和Vdm要注意顺序，要先有Labview编程软件，再安装vas和vdm，不然软件会识别不到。官网解释：这个错误常常产生于IMAQ Init VI被调用但是却没有正确的接口名称。但是我将NI MAX 中相机名称改成例程所示img0，运行依然失败。可能是IMAQ不支持笔记本相机。2.4 问题：摄像头如何打开和关闭？​    &nbsp;&nbsp;&nbsp;&nbsp;循环内停止程序也算是停止摄像头。\n2.5 问题：视频输出框不小心一直放大，如何缩小回正常状态？&nbsp;&nbsp;&nbsp;&nbsp;解决方法：右击视频输出框-【zoom to fit】\n2.6 问题：识别开始与识别停止开关如何添加？​    &nbsp;&nbsp;&nbsp;&nbsp;加个条件语句在开关识别中。\n2. 7 问题：一个显示暂时图片一个显示实时录像怎么实现？- 学习局部变量的用法，【结构】-【局部变量】右键控件可以【转化成读取】或【转化成写入】，选择好输入输出就可以右键【选择项】选择需要代替的局部变量。\n- 学习定时开启关闭布尔开关类型，布尔开关开启时控制识别，并实时输出，结束时结束字符识别，并结束视频识别。\n三、NI IMAQdx例程介绍3.1 The Acquire Every Image (Optimized Performance)​    &nbsp;&nbsp;&nbsp;&nbsp;Acquire Every Images（优化性能）示例显示了使用环形采集的基础知识。在VI的框图中更详细地描述了使用此模式的一些相机限制，但是如果可能，建议在性能关键的应用中使用此方法。\n概述：演示如何使用优化性能的环形采集来获取连续图像。\n要求：视觉采集软件\n说明：\n选择摄像机名称运行VI增加模拟处理延迟，以查看采集循环没有像相机获取图像那样快速执行时对后面图像和丢失图像的影响。3.2 The Acquire Every Image​    &nbsp;&nbsp;&nbsp;&nbsp;获取每个图像”示例显示了使用抓取获取获取每个图像的基础。抓取将图像数据从驱动程序分配的缓冲区复制到用户分配的缓冲区以供进一步处理。对于性能关键型应用程序，建议尽可能使用“获取每个图像（优化性能）”示例，以避免图像副本的额外开销。优化后的示例确实有一些限制，如VI所述。如果优化后的示例的要求限制过多，则应使用此示例。\n3.3 The Acquire Most Recent Image​    &nbsp;&nbsp;&nbsp;&nbsp;获取最新图像示例连续获取图像并使用抓取获取在图像控件中显示图像。它使用上一个新的获取模式来获取最新的图像，以避免等待获取新图像。\n概述：演示如何从相机获取最新的连续图像。\n要求：视觉采集软件\n3.4 The Acquire Most Recent Image (Express VI)&nbsp;&nbsp;&nbsp;&nbsp;获取最新图像（Express VI）示例连续获取图像，并使用Vision Acquisition Express VI在图像控件中显示图像。Express VI使配置获取变得简单，并允许您更改所选相机，或添加新属性或设置以更新，而无需编写任何代码。这个Express VI适合于入门和学习如何从相机获取图像并在LabVIEW中显示图像。\n概述：演示如何使用ExpressVI连续获取图像。\n要求：视觉采集软件\n说明：运行VI\n四、控件了解4.1 ROI Descriptor概念ROI：RIO是Region Of Interesting的简称，中译为目标区域。这个簇包含两个元素，Global Rectangle和Contours，其中Contours又是一个簇数组，其中的簇包含三个元素（ID,Type，Coordinates）。\n全局矩形Global Rectangle：包含了所有内部兴趣区域的外接矩形坐标点。一个图像上可能画有多个ROI，而包含这些所有ROI的外接矩形，则为全局矩形。它是一个一维数组。因为这种外接矩形是非旋转矩形，所以只有4个元素，左顶右底（即ROI左上角的X、Y，右下角的X、Y坐标）。经过实际验证，全局矩形的值即使不包含轮廓中的坐标点，处理的函数也会自动将全局矩形变成包含所有的ROI的外接矩形。\n轮廓Contours：是每个兴趣区域的单独形状，是一维数组。即多个ROI时，可能会有线、矩形、圆、弧等多个形状的ROI，则由轮廓中的数组来表示。每一个形状的ROI为一个数组元素。而这些数组元素则是由另外一个簇表示的，包含了标识、类型、坐标三个元素：\n标识ID：指定轮廓是ROI边缘的外部或内部区域。这个ID与ROI函数中的Contours Type轮廓类型是同一个变量。只是不同的表示方法而已（这个在NI的视觉中经常见到这样的名称不同但为同一概念的定义）。\n 类型Type：指定兴趣区域轮廓的具体形状类型。这个在ROI中定义为ROI Type兴趣区域类型，也是同一概念。\n坐标Coordinates：表示轮廓的在图像中的相对位置。很多ROI形状也只有4个元素，如直线、矩形等，这样的ROI的坐标与全局轮廓还是重合的。而像点ROI，则只有2个坐标，但是全局矩形仍然会有4个坐标。而当使用多段线时，则肯定有大于等于4个坐标点。\n五、课设要求&nbsp;&nbsp;&nbsp;&nbsp;Labview环境下调用摄像头识别视像头实时视频中的印刷体(如印刷于A4纸张上的大写单个黑体字符)如“A”、”B”、”C”、”D”等等。\nLabview面板上需包括:\n包括摄像头开启关闭开关识别开始停止开关结果刷新速度设定文本框. (可输入结果刷新速度，例如每1秒输出一次实时识，别结果)摄像内容实时显示控件4)识别结果文本框识别结果所对应的摄像头画面瞬时图片(可选)其他自定义内容(可选)六、完成情况6.1 识别循环设置模块&nbsp;&nbsp;&nbsp;&nbsp;识别循环设置模块采用一个WHILE大循环来循环判定识别开关的状态是否转变，以识别开关的键值来作为条件语句的执行条件，若打开识别开关，则其键值为真。可提前设定好需要识别的时间与显示识别结果的时间，并以平铺式顺序结构来确保子程序图按照从左到右的顺序执行，此部分功能类似布尔开关定时循环跳转变化。当识别开关为真，平铺式顺序结构中第一帧就会开始运行所设定的时间，运行成功后，第二帧开始运行显示识别时间，以此类推。\n\n6.2 摄像头瞬间显示模块&nbsp;&nbsp;&nbsp;&nbsp;摄像头瞬间显示模块采用识别循环设置中识别开关的局部变量键值来判断是否要瞬时识别摄像头内容 。流畅显示或者是瞬时显示的时间根据识别循环设置中两个时间来判定。归根结底就是正在识别的布尔开关状态来控制摄像头识别。这样保证在循环内，正在识别中时的摄像头是实时显示的摄像内容，当平铺式顺序结构中正在识别的布尔开关为假时便停止实时显示，开启瞬时显示。\n6.3 二值化分析模块&nbsp;&nbsp;&nbsp;&nbsp;二值化分析模块采用IMAQ中从彩色图像中提取单个平面的模块，实现形成灰度；对图像进行阈值设置，形成红色的图像，128为阈值期间使用的最低像素值，255为阈值期间使用的最高像素值。计算、生成图像的直方图，最终生成黑白的实时监控视频显示。三个图能够实时的对比分析，让人更加准确的抓住所要分析的内容。\n6.4 拍照保存照片模块&nbsp;&nbsp;&nbsp;&nbsp;拍照保存照片模块采用条件语句，主要由保存图片开关控制，将图像以所选格式写入文件。文件名由U64的随机数构成，并且抓拍获取得到图片格式可选。抓拍后图片显示为抓拍后的图片。图片存在所设置的路径当中，可供后期颜色对比分析。\n6.5 识别界面显示\n6.6 二值化分析显示\n","plink":"http://yoursite.com/2020/06/20/LabVIEW-Notes/"},{"title":"Air 724 Cat.1使用经历","date":"2020-06-19T10:45:32.000Z","date_formatted":{"ll":"2020年6月19日","L":"2020/06/19","MM-DD":"06-19"},"updated":"2020-10-21T03:54:44.140Z","content":"\n\n一、简述&nbsp;&nbsp;&nbsp;&nbsp;实习期间，从学习Axure，到跟踪进度，再到破解协议，没有一项做成。最后做回老本写写Lua，才感觉我实习不是在划水。接到的任务是将现有老人机从2G短信模式转化为4G Cat.1模式。从4月初开始学习 Cat.1，不过做熟悉的东西的感觉真好。但是在这过程中遇到好多问题，有解决的、有未解决的，每一天都很充实，很感激杜老师的细心教导。\n1.1 功能介绍\n一键紧急呼叫4G高清通话定时语音提醒WiFi定位、网络定位微信、APP配置电话防骚扰模式支持在线升级1.2 程序流程图\n\n二、开发板介绍2.1 板子外观\n\n2.2 开发板烧写\n&nbsp;&nbsp;&nbsp;&nbsp; Cat.1使用的烧录工具是Luatools_v2.exe，使用方法类似4G Cat.4的Luatools.exe。但是比Air 720 4G产品多了一个USB_BOOT–==USB下载模式==。\n&nbsp;&nbsp;&nbsp;&nbsp;下载方式：\n提前拨动开发板的拨动开发到on，长按开机键直到PWR灯亮Luatools_v2.exe中，选好固件版本，添加好lib库和用户脚本后点击【下载底层和脚本】，选中【USB BOOT下载】按住开发板U_BOOT按键，并按一下重启按键，就可以看到下载进度条开始了。注：手动添加lib就不勾选【添加默认lib】不加天线会导致拨号、WiFi信号获取失败三、重点问题3.1 掉电数据不保存\n&nbsp;&nbsp;&nbsp;&nbsp;官方有提供nvm的demo，nvm能够实现小数据量掉电保存，数据存储在.lua的文件中，开机需要初始化，测试发现，如果没有写require”nvm”会导致nvm操作失败。还有一点比较玄学，当定义两个table在global.lua文件中，一个空表a，一个默认配置表b，开机将b复制到a，当存储服务器修改后的配置在a表和b表的相关配置都修改。 掉电保存nvm合宙说明\n1require \"nvm\"  -- 不能缺\n开机初始化\n123456789101112require\"nvm\"require\"config\"nvm.init(\"config.lua\")-- 保存配置function p_cfgc_save_config()    local bool = nvm.set(\"g_cfgc_config\", global.g_cfgc_config)end-- 恢复出厂设置，使用时一定要require\"nvm\"nvm.restore()\nconfig.lua\n12345module(...)bootNum        = 1devStart       = falseg_cfgc_config  ={a}\n3.2 socket创建一直失败，用本地IP，用TCP-UDP工具监测\n​    &nbsp;&nbsp;&nbsp;&nbsp;socket创建需要公网IP，不能连接局域网，用Air 720就遇到过，解决后又忘了这一点。\n3.3  TTS与通话冲突\n​    &nbsp;&nbsp;&nbsp;&nbsp;TTS播放结束后进行打电话，利用TTS播放回调函数：\n12345678910-- 回调函数local function testCb(r)    clog.info(\"tesCall.ready\"..global.g_call_number)\tif r == 0 then\t\tcc.dial(global.g_call_number)\t\tclog.info(\"testAudio.testCb CALLING\",r)    endendaudio.play(7, \"TTS\", tts_str, 4, testCb)\n3.4  在其他文件调用发送数据给服务器函数报错\n1234567[E]-[coroutine.resume] /lua/socket.lua:277: socket:send: coroutine mismatchstack traceback:        [C]: in function 'assert'        /lua/socket.lua:277: in function 'send'        /lua/netproc.lua:49: in function 'p_netc_send'        /lua/netproc.lua:177: in function 'fast_send'        /lua/location.lua:104: in function &lt;/lua/location.lua:88&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道为什么出现这个问题，之后改成在哪个文件创建的发送数据函数，就在哪个文件中发送数据，才不会遇到这个问题，在其他文件调用，或者是回调中调用都会出现这个问题。\n3.5  在其他文件调用发送数据给服务器函数报错\n1234[2020-05-13 11:07:38.976] [W]-[lbsLoc.query] 根据基站查询经纬度失败[2020-05-13 11:07:38.986] [W]-[lbsLoc.query] main.lua中的PRODUCT_KEY和此设备在iot.openluat.com中所属项目的ProductKey必须一致，请去检[2020-05-13 11:07:38.986] 查[2020-05-13 11:07:38.986] [I]-[testLbsLoc.getLocCb] 5 nil nil\n&nbsp;&nbsp;&nbsp;&nbsp;Luat物联云平台中的PRODUCT_KEY和main.lua中的PRODUCT_KEY不一致。\n3.5  更新报错\n1已经是最新版\n只有脚本没有固件设备脚本和固件版本没有比云平台的低云平台中设备imei号码没有添加到升级文件下main.lua版本号写错了，如：12345PROJECT = \"SK-122-4G\"VERSION = \"1.1.9\"   --正确 一位数PROJECT = \"SK-122-4G\"VERSION = \"1.1.90\"   --错误 非一位数\n3.6  更新主动权在用户手上，不主动请求更新\n代码编写\n12345require \"update\"if 收到用户更新请求 then\t update.request(update_cbFnc)end\nLuat物联云平台设置\n\n升级失败解决方法\n官网合宙升级提示3.7  开发板拨号失败\n没有插天线联通卡没开通VOLTE通话：&nbsp;&nbsp;客户短信开通/退订方式：开通：DGVOLTE至10010；退订：TDVOLTE至100103.8  时间获取\n1234567891011121314-- ntp获取时间function p_tts_now_time()    local now_tts    local now_time = os.date(\"*t\")    now_tts =  global.g_tts_default.now_time..tostring(now_time[\"hour\"])..\"点\"..tostring(now_time[\"min\"])..\"分\"    audio.play(6, \"TTS\", now_tts, global.g_tts_volume)end-- 基站获取时间 联通不准function p_tts_now_time()    local now_tts    local now_time = misc.getClock()    now_tts =  global.g_tts_default.now_time..tostring(now_time[\"hour\"])..\"点\"..tostring(now_time[\"min\"])..\"分\"    audio.play(6, \"TTS\", now_tts, global.g_tts_volume)end\n\n\n四、常用知识点4.1  电压剩余指标\n\n电压:4.16-4.22V涓流补充:100%\n4.2  table和数组的区别\n数组的key只能是数字，table的key可以是数字或者字符串，table中还能嵌入tabletable是个对象，可以想成一种动态分配的对象ipairs和pairs的区别是有i的ipairs比较有个性，只会按key值升序遍历数组，遇到nil就退出不干了，适用于数组遍历；pairs没有i没有个性，老老实实将所有key遍历，适用于table。一直记不住两者区别，后来发现ipairs比较任性，i有i的想法。4.3 table按key排序\n&nbsp;&nbsp;&nbsp;&nbsp;例：将sort_table的表1-1排序成calling_table表1-2，按key_id是否为空排顺序排序\n1234567891011121314151617181920212223242526272829303132-- 表1-1TTS             =    {        TTS_1       =        {            time            = \"\",        },        TTS_5       =        {            time            = \"\",        },        TTS_3       =        {            time            = \"\",        },    }-- 表1-2TTS             =    {        TTS_1       =        {            time            = \"\",        },        TTS_3       =        {            time            = \"\",        },        TTS_5       =        {            time            = \"\",        },    }\n12345678910111213function p_call_table_sort( sort_table, calling_table ,key_id)    local key_test ={}    for i, v in pairs(sort_table) do        if v[key_id] ~= \"\" then            table.insert(key_test,i)   --提取test1中的键值插入到key_test表中            --clog.warning(\"p_call_table_sort:\"..i)        end    end    table.sort(key_test)    for i,v in pairs(key_test) do        table.insert(calling_table,sort_table[v])    endend\n4.3 批量操作\n123456789101112131415161718-- data支持批量操作，保存全部的信息                for i,value in pairs(real_data.data) do                    if value[\"type\"] == 1 then                        local phone_id = \"phone_\"..tostring(value[\"id\"])                        clog.warning(\"更新通信录1:\"..phone_id..value[\"name\"]..value[\"phone\"])                        global.g_cfgc_config.phone[phone_id][\"name\"]           = value[\"name\"]                        global.g_cfgc_config.phone[phone_id][\"phone\"]          = value[\"phone\"]                        global.g_cfgc_config.phone[phone_id][\"dialmode\"]       = value[\"dialmode\"]                        global.g_cfgc_config.phone[phone_id][\"type\"]           = 1                    elseif value[\"type\"] == 2 then                        local phone_id = \"Whitlst_\"..tostring(value[\"id\"])                        clog.warning(\"更新通信录2:\"..phone_id..value[\"name\"]..value[\"phone\"])                        global.g_cfgc_config.Whitlst[phone_id][\"name\"]           = value[\"name\"]                        global.g_cfgc_config.Whitlst[phone_id][\"phone\"]          = value[\"phone\"]                        global.g_cfgc_config.Whitlst[phone_id][\"dialmode\"]       = value[\"dialmode\"]                        global.g_cfgc_config.Whitlst[phone_id][\"type\"]           = 2                    end                end\n4.5  固定TTS播放\n1234567891011121314151617181920212223242526272829303132333435363738394041424344local now_time = p_timing_now_time()    local week = misc.getWeek()    -- 只有在接收服务器更新的时候排序    if tts_update == true then        tts_table  = {}        tools.p_call_table_sort( global.g_cfgc_config.TTS, tts_table,\"text\" )        tts_update = false    end    --clog.error(\"tts_table\"..#tts_table)    if  #tts_table ~= 0 then        for i, v in pairs(tts_table) do            local week_t = tonumber(v[\"week\"])            for j=1,7 do                local flag = bit.isset( week_t, j )                --clog.warning(j..\":j flag:\"..tools.true2int(flag))                if flag == true then                    -- 判断提醒的是周几                     table.insert( tts_week, j, j )                    --clog.warning(j..\":tts_week:\"..tts_week[j])                end            end            -- 今天是是否有提醒            if tts_week[week] ~= nil then                if  v[\"time\"] == now_time then                    clog.error(v[\"time\"]..\"v[time] and now_time :\"..now_time..\"global week:\"..week_t..week)                    audio.play(7, \"TTS\", v[\"text\"], global.g_tts_volume)                    if v[\"repeated\"] == 0 then                        tts_count = tts_count + 1                    end                end                 -- 若为提醒完 并且配置为不重复                 if tts_count &gt; 4 and v[\"repeated\"] == 0 then                    tts_count = 0                    local num = bit.clear( tonumber(v[\"week\"]), week)                    v[\"week\"] = tostring(num)                    --clog.debug(num..\":num and v[week]:\"..v[\"week\"])                    main_proc.p_cfgc_save_config()                    tts_update = true                end            end                   end    end\n五、学习链接5.1  JSON在线解析\n5.2  草料二维码在线生成\n5.3  HEX字符串互相转换\n5.4  掉电保存nvm\n1require \"nvm\"  -- 不能缺\n5.5 xml转json\n5.6  合宙升级提示\n5.7  724UG抓取AP日志\n","plink":"http://yoursite.com/2020/06/19/Air-724-Cat-1使用经历/"},{"title":"合宙Lua开发资料汇总","date":"2020-05-29T09:43:00.000Z","date_formatted":{"ll":"2020年5月29日","L":"2020/05/29","MM-DD":"05-29"},"author":"巧玉","updated":"2020-11-20T11:57:33.652Z","content":"\n\n一、软件安装下载工具：Luatools验证工具：Lua editor（针对Lua标准库，无法用合宙API和扩展API）编写工具：Visual Studio Code二、资料下载方式官网帖子：合宙模块相关资料汇总 LUA合集（重要）官网–产品中心–资料下载（最常用以下6个文档）\n\n三、常用网站菜鸟教程：Lua教程 Lua5.3参考手册Lua系列教程：晨旭的博客合宙问答社区：问答合宙wiki：wiki本地wiki：\n四、常用官网QQ群合宙Luat(Cat.1模块)：1092305811合宙&amp;飞思创:WiFi模块：679177589合宙Luat通信模块(1)：604902189合宙流量卡充钱负责人：837312392五、其他安装完LuaTools要定时删日志，不然很占电脑内存&nbsp;&nbsp;&nbsp;找到他的安装目录，安装目录如下：\n\n&nbsp;&nbsp;&nbsp;点开log文件夹就是运行LuaTools所有的日志情况，看以往的trace_xxxx.txt就可以看历史日志\n\n&nbsp;&nbsp;&nbsp;还有4gdiag中也有许多bin和tra文件，出问题可以把对应的bin、tra、trace.txt发送给合宙人员解析。（这一部分很占内存）\n\n​    &nbsp;&nbsp;&nbsp;也可关闭自动保存日志，LuaTools-&gt;选项-&gt;工具配置-&gt;取消不需要的勾，关闭重启软件即可保存配置\n\n代码和底层可以合并或者加密，代码安全性&nbsp;&nbsp;&nbsp;LuaTools中添加好需要生成的core+代码，点击生成量产文件之后，找到量产文件保存路径，有两个文件夹。\n\n\n&nbsp;&nbsp;&nbsp;在4G量产文件夹中可以看到，生成和底层core一样pac文件，这个文件就包含用户脚本+底层core。\n\n&nbsp;&nbsp;&nbsp;另外的升级文件，在物联网云平台中上传升级固件包会用到。\n官方例程&nbsp;&nbsp;&nbsp;几乎所有功能官方都有例程，在例程上进行修改就可以完成所需要的功能。\n\n","plink":"http://yoursite.com/2020/05/29/合宙Lua开发资料汇总/"},{"title":"你比春天先拥抱了我","date":"2020-02-20T14:59:00.000Z","date_formatted":{"ll":"2020年2月20日","L":"2020/02/20","MM-DD":"02-20"},"updated":"2020-07-30T00:49:12.586Z","content":"\n\n一、简述&nbsp;&nbsp;&nbsp;&nbsp;历经千辛万苦终于把自己的小天地搭起来了，希望接下来好好经营，把学习笔记、心得感想、兴趣爱好、回忆以及风景等好好记录下来。\n&nbsp;&nbsp;&nbsp;&nbsp;大三也算是人生的转折点吧，每个人都在问考研否？考公否？工作否？而这个肺炎，让我更不想去接触即将面临的问题，但是也喜欢上这种有空就搞搞小东西，学学新知识。虽然老是遇到问题，但是看到成果的一刻是十分兴奋的。\n&nbsp;&nbsp;&nbsp;&nbsp;希望生活多一点冲动，少一点伤害。\n二、搭建博客遇到的问题问题011bash: cnpm: command not found\n原因&nbsp;&nbsp;&nbsp;&nbsp;  cnpm没有安装成功。\n解决方法1npm install -g cnpm --registry=https://registry.npm.taobao.org\n验证是否安装成功\n问题021bash:hexo:command not found\n原因&nbsp;&nbsp;&nbsp;&nbsp;按理来说我按网上教学一步步来应该没有问题，但是我hexo一直安装不上，之后学长帮我卸载重装，他说直接用npm换源，就可以不用cnpm。\n解决方法1npm install-g hexo\n验证是否安装成功1hexo -v\n\n问题03描述\n原因及解决方法&nbsp;&nbsp;&nbsp;&nbsp;  同上，是重装解决的。\n问题04描述1FATAL Port 4000 has been used. Try other port instead.\n原因 &nbsp;&nbsp;&nbsp;&nbsp; 4000被占用了，可以用其他的或杀掉。\n解决方法1$ sudo hexo s -p 5000\n问题05描述  1234deploy:    type: git    repo: https://github.com/xxx/xxx.github.io.git    branch: master\n注意点Github新建存储库命名要与自己用户名相同，否者要改名。修改目录_config.yml中的上段代码要注意：后面要加一个空格。repo中是存储库的HTTPS而不是SSH。\n问题06描述  &nbsp;&nbsp;&nbsp;&nbsp;git安装主题后，上传更新后一直失败的。\n原因没有修改目录_config.yml中的主题配置主题文件夹放置错误解决方法修改目录_config.yml中的主题配置1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia\n保证主题文件夹yilia在\\themes之下如：\\themes\\yilia三、Yilia主题修改1. 头像等图像修改图片储存地址1\\public\\img\n例子 &nbsp;&nbsp;&nbsp;&nbsp; 我头像的位置：\n\n  &nbsp;&nbsp;&nbsp;&nbsp;代码修改：\n12#你的头像urlavatar: /img/avatar.jpg\n2. QQ加好友链接1qq: http://wpa.qq.com/msgrd?v=3&amp;uin=2551165612&amp;site=qq&amp;menu=yes\n&nbsp;&nbsp;&nbsp;&nbsp;   把QQ号部分修改成自己的QQ号\n四、上传文章遇到的问题问题01描述1YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:\n原因 &nbsp;&nbsp;&nbsp;&nbsp; 第四行的tags：后面没有空格。\n解决方法 &nbsp;&nbsp;&nbsp;&nbsp; 第四行的tags：加一个空格。\n问题02描述1TypeError: Cannot read property 'utcOffset' of null\n原因&nbsp;&nbsp;&nbsp;&nbsp;  时区错误，我把目录_config.yml中的时区写成Asia/Xiamen，哈哈哈，改成Asia/Shanghai就好了。\n解决方法12345678# Sitetitle: subtitle: 红了芭蕉，绿了樱桃description: 看着很厉害，又好看就完事了keywords:author: Sua-cqylanguage: zh-CNtimezone: Asia/Shanghai\n问题03描述  &nbsp;&nbsp;&nbsp;&nbsp;图片上传失败。\n解决方法安装插件1npm install hexo-asset-image --save\n在_config.yml配置文件中，修改1post_asset_folder: true\n新建文章，source/_posts中有相关文章名文件夹1hexo new post title\ntypora设置：格式–图像–当插入本地图片时–复制图片到文件夹–选中路径：/source/_posts/文章名的文件夹五、指令学习1. 新建文章1hexo new \"title\"\n2. 当前路径1pwd\n3. 该路径下文件1ls -l\n4. 指定路径1cd source/_posts/\n5. 清理1hexo clean\n6. 上传12hexo ghexo d","plink":"http://yoursite.com/2020/02/20/你比春天先拥抱了我/"},{"title":"Hello World","date":"2020-02-19T12:58:15.373Z","date_formatted":{"ll":"2020年2月19日","L":"2020/02/19","MM-DD":"02-19"},"updated":"2020-07-30T00:44:23.221Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\nMore info: Writing\nRun server1$ hexo server\nMore info: Server\nGenerate static files1$ hexo generate\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\nMore info: Deployment\n","plink":"http://yoursite.com/2020/02/19/hello-world/"}]